"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const isVim = process.env.VIM_NODE_RPC == '1';
// i.e. a plugin that detaches will affect all plugins registered on host
// const EXCLUDED = ['nvim_buf_attach', 'nvim_buf_detach']
// Instead of dealing with multiple inheritance (or lackof), just extend EE
// Only the Neovim API class should use EE though
class BaseApi extends events_1.EventEmitter {
    constructor({ transport, data, client, }) {
        super();
        this.setTransport(transport);
        this.data = data;
        this.client = client;
    }
    setTransport(transport) {
        this.transport = transport;
    }
    equals(other) {
        try {
            return String(this.data) === String(other.data);
        }
        catch (e) {
            return false;
        }
    }
    request(name, args = []) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                this.transport.request(name, this.getArgsByPrefix(args), (err, res) => {
                    if (err) {
                        reject(new Error(`request error ${name} - ${err[1]}`));
                    }
                    else {
                        resolve(res);
                    }
                });
            });
        });
    }
    getArgsByPrefix(args) {
        // Check if class is Neovim and if so, should not send `this` as first arg
        if (this.prefix !== 'nvim_' && args[0] != this) {
            let id = isVim ? this.data : this;
            return [id, ...args];
        }
        return args;
    }
    /** Retrieves a scoped variable depending on type (using `this.prefix`) */
    getVar(name) {
        return this.request(`${this.prefix}get_var`, [name]).then(res => res, _err => {
            return null;
        });
    }
    setVar(name, value, isNotify = false) {
        if (isNotify) {
            this.notify(`${this.prefix}set_var`, [name, value]);
            return;
        }
        return this.request(`${this.prefix}set_var`, [name, value]);
    }
    /** Delete a scoped variable */
    deleteVar(name) {
        this.notify(`${this.prefix}del_var`, [name]);
    }
    /** Retrieves a scoped option depending on type of `this` */
    getOption(name) {
        return this.request(`${this.prefix}get_option`, [name]);
    }
    setOption(name, value, isNotify) {
        if (isNotify) {
            this.notify(`${this.prefix}set_option`, [name, value]);
            return;
        }
        return this.request(`${this.prefix}set_option`, [name, value]);
    }
    /** `request` is basically the same except you can choose to wait forpromise to be resolved */
    notify(name, args = []) {
        this.transport.notify(name, this.getArgsByPrefix(args));
    }
}
exports.BaseApi = BaseApi;
