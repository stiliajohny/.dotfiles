import { BaseApi } from './Base';
export interface BufferSetLines {
    start?: number;
    end?: number;
    strictIndexing?: boolean;
}
export interface BufferHighlight {
    hlGroup?: string;
    line?: number;
    colStart?: number;
    colEnd?: number;
    srcId?: number;
}
export interface BufferClearHighlight {
    srcId?: number;
    lineStart?: number;
    lineEnd?: number;
}
export interface Disposable {
    /**
     * Dispose this object.
     */
    dispose(): void;
}
declare type Chunk = [string, string];
export declare class Buffer extends BaseApi {
    prefix: string;
    /**
     * Attach to buffer to listen to buffer events
     * @param sendBuffer Set to true if the initial notification should contain
     *        the whole buffer. If so, the first notification will be a
     *        `nvim_buf_lines_event`. Otherwise, the first notification will be
     *        a `nvim_buf_changedtick_event`
     */
    attach(sendBuffer?: boolean, options?: {}): Promise<boolean>;
    /**
     * Detach from buffer to stop listening to buffer events
     */
    detach(): Promise<boolean>;
    /**
     * Get the bufnr of Buffer
     */
    readonly id: number;
    /** Total number of lines in buffer */
    readonly length: Promise<number>;
    /** Get lines in buffer */
    readonly lines: Promise<string[]>;
    /** Gets a changed tick of a buffer */
    readonly changedtick: Promise<number>;
    readonly commands: Promise<Object>;
    getCommands(options?: {}): Promise<Object>;
    /** Get specific lines of buffer */
    getLines({ start, end, strictIndexing }?: {
        start: number;
        end: number;
        strictIndexing: boolean;
    }): Promise<string[]>;
    /** Set lines of buffer given indeces */
    setLines(_lines: string | string[], { start: _start, end: _end, strictIndexing }?: BufferSetLines, notify?: boolean): void | Promise<any>;
    /**
     * Set virtual text for a line
     *
     * @public
     * @param {number} src_id - Source group to use or 0 to use a new group, or -1
     * @param {number} line - Line to annotate with virtual text (zero-indexed)
     * @param {Chunk[]} chunks - List with [text, hl_group]
     * @param {{[index} opts
     * @returns {Promise<number>}
     */
    setVirtualText(src_id: number, line: number, chunks: Chunk[], opts?: {
        [index: string]: any;
    }): Promise<number>;
    /** Insert lines at `start` index */
    insert(lines: string[] | string, start: number): void | Promise<any>;
    /** Replace lines starting at `start` index */
    replace(_lines: string[] | string, start: number): void | Promise<any>;
    /** Remove lines at index */
    remove(start: number, end: number, strictIndexing?: boolean): void | Promise<any>;
    /** Append a string or list of lines to end of buffer */
    append(lines: string[] | string): void | Promise<any>;
    /** Get buffer name */
    readonly name: Promise<string>;
    /** Set current buffer name */
    setName(value: string): Promise<void>;
    /** Is current buffer valid */
    readonly valid: Promise<boolean>;
    /** Get mark position given mark name */
    mark(name: string): Promise<[number, number]>;
    /** Gets keymap */
    getKeymap(mode: string): Promise<object[]>;
    /**
   * Checks if a buffer is valid and loaded. See |api-buffer| for
   * more info about unloaded buffers.
   */
    readonly loaded: Promise<boolean>;
    /**
     * Returns the byte offset for a line.
     *
     * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is
     * one byte. 'fileformat' and 'fileencoding' are ignored. The
     * line index just after the last line gives the total byte-count
     * of the buffer. A final EOL byte is counted if it would be
     * written, see 'eol'.
     *
     * Unlike |line2byte()|, throws error for out-of-bounds indexing.
     * Returns -1 for unloaded buffer.
     *
     * @return {Number} Integer byte offset, or -1 for unloaded buffer.
     */
    getOffset(index: number): Promise<number>;
    /**
      Adds a highlight to buffer.
  
      This can be used for plugins which dynamically generate
      highlights to a buffer (like a semantic highlighter or
      linter). The function adds a single highlight to a buffer.
      Unlike matchaddpos() highlights follow changes to line
      numbering (as lines are inserted/removed above the highlighted
      line), like signs and marks do.
  
      "src_id" is useful for batch deletion/updating of a set of
      highlights. When called with src_id = 0, an unique source id
      is generated and returned. Succesive calls can pass in it as
      "src_id" to add new highlights to the same source group. All
      highlights in the same group can then be cleared with
      nvim_buf_clear_highlight. If the highlight never will be
      manually deleted pass in -1 for "src_id".
  
      If "hl_group" is the empty string no highlight is added, but a
      new src_id is still returned. This is useful for an external
      plugin to synchrounously request an unique src_id at
      initialization, and later asynchronously add and clear
      highlights in response to buffer changes. */
    addHighlight({ hlGroup: _hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId, }: BufferHighlight): Promise<number | null>;
    /** Clears highlights from a given source group and a range of
    lines
    To clear a source group in the entire buffer, pass in 1 and -1
    to lineStart and lineEnd respectively. */
    clearHighlight(args?: BufferClearHighlight): void;
    clearNamespace(id: number, lineStart?: number, lineEnd?: number): void;
    /**
     * Listens to buffer for events
     */
    listen(eventName: string, cb: Function, disposables?: Disposable[]): void;
}
export {};
