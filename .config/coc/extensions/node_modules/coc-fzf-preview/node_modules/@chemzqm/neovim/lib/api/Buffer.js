"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Base_1 = require("./Base");
class Buffer extends Base_1.BaseApi {
    constructor() {
        super(...arguments);
        this.prefix = 'nvim_buf_';
    }
    /**
     * Attach to buffer to listen to buffer events
     * @param sendBuffer Set to true if the initial notification should contain
     *        the whole buffer. If so, the first notification will be a
     *        `nvim_buf_lines_event`. Otherwise, the first notification will be
     *        a `nvim_buf_changedtick_event`
     */
    attach(sendBuffer = false, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request(`${this.prefix}attach`, [sendBuffer, options]);
        });
    }
    /**
     * Detach from buffer to stop listening to buffer events
     */
    detach() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request(`${this.prefix}detach`, []);
        });
    }
    /**
     * Get the bufnr of Buffer
     */
    get id() {
        return this.data;
    }
    /** Total number of lines in buffer */
    get length() {
        return this.request(`${this.prefix}line_count`, []);
    }
    /** Get lines in buffer */
    get lines() {
        return this.getLines();
    }
    /** Gets a changed tick of a buffer */
    get changedtick() {
        return this.request(`${this.prefix}get_changedtick`, []);
    }
    get commands() {
        return this.getCommands();
    }
    getCommands(options = {}) {
        return this.request(`${this.prefix}get_commands`, [options]);
    }
    /** Get specific lines of buffer */
    getLines({ start, end, strictIndexing } = { start: 0, end: -1, strictIndexing: true }) {
        const indexing = typeof strictIndexing === 'undefined' ? true : strictIndexing;
        return this.request(`${this.prefix}get_lines`, [
            start,
            end,
            indexing,
        ]);
    }
    /** Set lines of buffer given indeces */
    setLines(_lines, { start: _start, end: _end, strictIndexing } = {
        strictIndexing: true,
    }, notify = false) {
        // TODO: Error checking
        // if (typeof start === 'undefined' || typeof end === 'undefined') {
        // }
        const indexing = typeof strictIndexing === 'undefined' ? true : strictIndexing;
        const lines = typeof _lines === 'string' ? [_lines] : _lines;
        const end = typeof _end !== 'undefined' ? _end : _start + 1;
        const method = notify ? 'notify' : 'request';
        return this[method](`${this.prefix}set_lines`, [
            _start,
            end,
            indexing,
            lines,
        ]);
    }
    /**
     * Set virtual text for a line
     *
     * @public
     * @param {number} src_id - Source group to use or 0 to use a new group, or -1
     * @param {number} line - Line to annotate with virtual text (zero-indexed)
     * @param {Chunk[]} chunks - List with [text, hl_group]
     * @param {{[index} opts
     * @returns {Promise<number>}
     */
    setVirtualText(src_id, line, chunks, opts = {}) {
        this.notify(`${this.prefix}set_virtual_text`, [
            src_id,
            line,
            chunks,
            opts,
        ]);
        return Promise.resolve(src_id);
    }
    /** Insert lines at `start` index */
    insert(lines, start) {
        return this.setLines(lines, {
            start,
            end: start,
            strictIndexing: true,
        });
    }
    /** Replace lines starting at `start` index */
    replace(_lines, start) {
        const lines = typeof _lines === 'string' ? [_lines] : _lines;
        return this.setLines(lines, {
            start,
            end: start + lines.length,
            strictIndexing: false,
        });
    }
    /** Remove lines at index */
    remove(start, end, strictIndexing = false) {
        return this.setLines([], { start, end, strictIndexing });
    }
    /** Append a string or list of lines to end of buffer */
    append(lines) {
        return this.setLines(lines, {
            start: -1,
            end: -1,
            strictIndexing: false,
        });
    }
    /** Get buffer name */
    get name() {
        return this.request(`${this.prefix}get_name`, []);
    }
    /** Set current buffer name */
    setName(value) {
        return this.request(`${this.prefix}set_name`, [value]);
    }
    /** Is current buffer valid */
    get valid() {
        return this.request(`${this.prefix}is_valid`, []);
    }
    /** Get mark position given mark name */
    mark(name) {
        return this.request(`${this.prefix}get_mark`, [name]);
    }
    // range(start, end) {
    // """Return a `Range` object, which represents part of the Buffer."""
    // return Range(this, start, end)
    // }
    /** Gets keymap */
    getKeymap(mode) {
        return this.request(`${this.prefix}get_keymap`, [mode]);
    }
    /**
   * Checks if a buffer is valid and loaded. See |api-buffer| for
   * more info about unloaded buffers.
   */
    get loaded() {
        return this.request(`${this.prefix}is_loaded`, []);
    }
    /**
     * Returns the byte offset for a line.
     *
     * Line 1 (index=0) has offset 0. UTF-8 bytes are counted. EOL is
     * one byte. 'fileformat' and 'fileencoding' are ignored. The
     * line index just after the last line gives the total byte-count
     * of the buffer. A final EOL byte is counted if it would be
     * written, see 'eol'.
     *
     * Unlike |line2byte()|, throws error for out-of-bounds indexing.
     * Returns -1 for unloaded buffer.
     *
     * @return {Number} Integer byte offset, or -1 for unloaded buffer.
     */
    getOffset(index) {
        return this.request(`${this.prefix}get_offset`, [index]);
    }
    /**
      Adds a highlight to buffer.
  
      This can be used for plugins which dynamically generate
      highlights to a buffer (like a semantic highlighter or
      linter). The function adds a single highlight to a buffer.
      Unlike matchaddpos() highlights follow changes to line
      numbering (as lines are inserted/removed above the highlighted
      line), like signs and marks do.
  
      "src_id" is useful for batch deletion/updating of a set of
      highlights. When called with src_id = 0, an unique source id
      is generated and returned. Succesive calls can pass in it as
      "src_id" to add new highlights to the same source group. All
      highlights in the same group can then be cleared with
      nvim_buf_clear_highlight. If the highlight never will be
      manually deleted pass in -1 for "src_id".
  
      If "hl_group" is the empty string no highlight is added, but a
      new src_id is still returned. This is useful for an external
      plugin to synchrounously request an unique src_id at
      initialization, and later asynchronously add and clear
      highlights in response to buffer changes. */
    addHighlight({ hlGroup: _hlGroup, line, colStart: _start, colEnd: _end, srcId: _srcId, }) {
        const hlGroup = typeof _hlGroup !== 'undefined' ? _hlGroup : '';
        const colEnd = typeof _end !== 'undefined' ? _end : -1;
        const colStart = typeof _start !== 'undefined' ? _start : -0;
        const srcId = typeof _srcId !== 'undefined' ? _srcId : -1;
        const method = hlGroup === '' ? 'request' : 'notify';
        let res = this[method](`${this.prefix}add_highlight`, [
            srcId,
            hlGroup,
            line,
            colStart,
            colEnd,
        ]);
        return method === 'request' ? res : Promise.resolve(null);
    }
    /** Clears highlights from a given source group and a range of
    lines
    To clear a source group in the entire buffer, pass in 1 and -1
    to lineStart and lineEnd respectively. */
    clearHighlight(args = {}) {
        const defaults = {
            srcId: -1,
            lineStart: 0,
            lineEnd: -1,
        };
        const { srcId, lineStart, lineEnd } = Object.assign({}, defaults, args);
        return this.notify(`${this.prefix}clear_highlight`, [
            srcId,
            lineStart,
            lineEnd,
        ]);
    }
    clearNamespace(id, lineStart = 0, lineEnd = -1) {
        return this.notify(`${this.prefix}clear_namespace`, [
            id,
            lineStart,
            lineEnd,
        ]);
    }
    /**
     * Listens to buffer for events
     */
    listen(eventName, cb, disposables) {
        this.client.attachBufferEvent(this, eventName, cb);
        if (disposables) {
            disposables.push({
                dispose: () => {
                    this.client.detachBufferEvent(this, eventName, cb);
                }
            });
        }
    }
}
exports.Buffer = Buffer;
