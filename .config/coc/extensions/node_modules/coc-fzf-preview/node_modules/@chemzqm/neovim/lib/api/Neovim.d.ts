import { ApiInfo } from '../types/ApiInfo';
import { VimValue } from '../types/VimValue';
import { BaseApi } from './Base';
import { Buffer } from './Buffer';
import { Tabpage } from './Tabpage';
import { Window } from './Window';
import { FloatOptions } from './types';
export interface UiAttachOptions {
    rgb?: boolean;
    ext_popupmenu?: boolean;
    ext_tabline?: boolean;
    ext_wildmenu?: boolean;
    ext_cmdline?: boolean;
    ext_linegrid?: boolean;
    ext_hlstate?: boolean;
}
export interface Proc {
    ppid: number;
    name: string;
    pid: number;
}
/**
 * Neovim API
 */
export declare class Neovim extends BaseApi {
    protected prefix: string;
    Buffer: typeof Buffer;
    Window: typeof Window;
    Tabpage: typeof Tabpage;
    private getArgs;
    readonly apiInfo: Promise<[number, ApiInfo]>;
    /** Get list of all buffers */
    readonly buffers: Promise<Buffer[]>;
    /** Get current buffer */
    readonly buffer: Promise<Buffer>;
    /** Set current buffer */
    setBuffer(buffer: Buffer): Promise<void>;
    readonly chans: Promise<number[]>;
    getChanInfo(chan: number): Promise<object>;
    createNamespace(name?: string): Promise<number>;
    readonly namespaces: Promise<{
        [name: string]: number;
    }>;
    readonly commands: Promise<Object>;
    getCommands(options?: {}): Promise<Object>;
    /** Get list of all tabpages */
    readonly tabpages: Promise<Tabpage[]>;
    /** Get current tabpage */
    readonly tabpage: Promise<Tabpage>;
    /** Set current tabpage */
    setTabpage(tabpage: Tabpage): Promise<void>;
    /** Get list of all windows */
    readonly windows: Promise<Window[]>;
    /** Get current window */
    readonly window: Promise<Window>;
    /** Get list of all windows */
    getWindows(): Promise<Window[]>;
    setWindow(win: Window): Promise<void>;
    /** Get list of all runtime paths */
    readonly runtimePaths: Promise<string[]>;
    /** Set current directory */
    setDirectory(dir: string): Promise<void>;
    /** Get current line. Always returns a Promise. */
    readonly line: Promise<string>;
    createNewBuffer(listed?: boolean, scratch?: boolean): Promise<Buffer>;
    openFloatWindow(buffer: Buffer, enter: boolean, options: FloatOptions): Promise<Window>;
    getLine(): Promise<string>;
    /** Set current line */
    setLine(line: string): Promise<any>;
    /** Gets keymap */
    getKeymap(mode: string): Promise<object[]>;
    /** Gets current mode */
    readonly mode: Promise<{
        mode: string;
        blocking: boolean;
    }>;
    /** Gets map of defined colors */
    readonly colorMap: Promise<{
        [name: string]: number;
    }>;
    /** Get color by name */
    getColorByName(name: string): Promise<number>;
    /** Get highlight by name or id */
    getHighlight(nameOrId: string | number, isRgb?: boolean): Promise<object> | void;
    getHighlightByName(name: string, isRgb?: boolean): Promise<object>;
    getHighlightById(id: number, isRgb?: boolean): Promise<object>;
    /** Delete current line in buffer */
    deleteCurrentLine(): Promise<any>;
    /**
     * Evaluates a VimL expression (:help expression). Dictionaries
     * and Lists are recursively expanded. On VimL error: Returns a
     * generic error; v:errmsg is not updated.
     *
     */
    eval(expr: string): Promise<VimValue>;
    /**
     * Executes lua, it's possible neovim client does not support this
     */
    lua(code: string, args?: VimValue[]): Promise<object>;
    executeLua(code: string, args?: VimValue[]): Promise<object>;
    callDictFunction(dict: object, fname: string, args?: VimValue | VimValue[]): object;
    /** Call a vim function */
    call(fname: string, args?: VimValue | VimValue[]): Promise<any>;
    call(fname: string, args: VimValue | VimValue[], isNotify: true): null;
    /** Call a function with timer on vim*/
    callTimer(fname: string, args?: VimValue | VimValue[]): Promise<null>;
    callTimer(fname: string, args: VimValue | VimValue[], isNotify: true): null;
    callAsync(fname: string, args?: VimValue | VimValue[]): Promise<any>;
    /** Alias for `call` */
    callFunction(fname: string, args?: VimValue | VimValue[]): Promise<any> | null;
    /** Call Atomic calls */
    callAtomic(calls: [string, VimValue[]][]): Promise<[any[], boolean]>;
    /** Runs a vim command */
    command(arg: string): Promise<any>;
    command(arg: string, isNotify: true): null;
    /** Runs a command and returns output (synchronous?) */
    commandOutput(arg: string): Promise<string>;
    /** Gets a v: variable */
    getVvar(name: string): Promise<VimValue>;
    /** feedKeys */
    feedKeys(keys: string, mode: string, escapeCsi: boolean): Promise<any>;
    /** Sends input keys */
    input(keys: string): Promise<number>;
    /**
     * Parse a VimL Expression
     *
     * TODO: return type, see :help
     */
    parseExpression(expr: string, flags: string, highlight: boolean): Promise<object>;
    getProc(pid: number): Promise<Proc>;
    getProcChildren(pid: number): Promise<Proc[]>;
    /** Replace term codes */
    replaceTermcodes(str: string, fromPart: boolean, doIt: boolean, special: boolean): Promise<string>;
    /** Gets width of string */
    strWidth(str: string): Promise<number>;
    /** Write to output buffer */
    outWrite(str: string): void;
    outWriteLine(str: string): void;
    /** Write to error buffer */
    errWrite(str: string): void;
    /** Write to error buffer */
    errWriteLine(str: string): void;
    readonly uis: Promise<any[]>;
    uiAttach(width: number, height: number, options: UiAttachOptions): Promise<void>;
    uiDetach(): Promise<void>;
    uiTryResize(width: number, height: number): Promise<void>;
    /** Set UI Option */
    uiSetOption(name: string, value: any): Promise<void>;
    /** Subscribe to nvim event broadcasts */
    subscribe(event: string): Promise<void>;
    /** Unsubscribe to nvim event broadcasts */
    unsubscribe(event: string): Promise<void>;
    setClientInfo(name: string, version: object, type: string, methods: object, attributes: object): void;
    /** Quit nvim */
    quit(): Promise<void>;
}
