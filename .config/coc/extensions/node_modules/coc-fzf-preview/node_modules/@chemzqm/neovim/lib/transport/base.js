"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const logger_1 = require("../utils/logger");
const debug = process.env.NODE_CLIENT_LOG_LEVEL == 'debug';
const logger = logger_1.createLogger('transport');
class Transport extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.pauseLevel = 0;
        this.paused = new Map();
    }
    debug(key, ...meta) {
        if (!debug)
            return;
        logger.debug(key, ...meta);
    }
    info(key, ...meta) {
        logger.info(key, ...meta);
    }
    debugMessage(msg) {
        if (!debug)
            return;
        const msgType = msg[0];
        if (msgType == 0) {
            logger.debug('receive request:', msg.slice(1));
        }
        else if (msgType == 1) {
            // logger.debug('receive response:', msg.slice(1))
        }
        else if (msgType == 2) {
            logger.debug('receive notification:', msg.slice(1));
        }
        else {
            logger.debug('unknown message:', msg);
        }
    }
    pauseNotification() {
        this.pauseLevel = this.pauseLevel + 1;
        this.paused.set(this.pauseLevel, []);
    }
    cancelNotification() {
        let { pauseLevel } = this;
        if (pauseLevel > 0) {
            this.paused.delete(pauseLevel);
            this.pauseLevel = pauseLevel - 1;
        }
    }
    resumeNotification(isNotify = false) {
        let { pauseLevel } = this;
        if (pauseLevel == 0)
            return isNotify ? null : Promise.resolve([null, null]);
        this.pauseLevel = pauseLevel - 1;
        let list = this.paused.get(pauseLevel);
        this.paused.delete(pauseLevel);
        if (list && list.length) {
            return new Promise((resolve, reject) => {
                if (!isNotify) {
                    return this.request('nvim_call_atomic', [list], (err, res) => {
                        if (err)
                            return reject(new Error(`call_atomic error: ${err[1]}`));
                        resolve(res);
                    });
                }
                this.notify('nvim_call_atomic', [list]);
                resolve();
            });
        }
        return isNotify ? null : Promise.resolve([[], undefined]);
    }
}
exports.default = Transport;
