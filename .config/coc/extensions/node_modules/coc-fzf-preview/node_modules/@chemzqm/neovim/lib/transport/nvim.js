"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const msgpack = __importStar(require("msgpack-lite"));
const buffered_1 = __importDefault(require("../utils/buffered"));
const types_1 = require("../api/types");
const base_1 = __importDefault(require("./base"));
class NvimTransport extends base_1.default {
    constructor() {
        super();
        this.pending = new Map();
        this.nextRequestId = 1;
        this.attached = false;
        const codec = this.setupCodec();
        this.encodeStream = msgpack.createEncodeStream({ codec });
        this.decodeStream = msgpack.createDecodeStream({ codec });
        this.decodeStream.on('data', (msg) => {
            this.parseMessage(msg);
        });
        this.decodeStream.on('end', () => {
            this.detach();
            this.emit('detach');
        });
    }
    parseMessage(msg) {
        const msgType = msg[0];
        this.debugMessage(msg);
        if (msgType === 0) {
            // request
            //   - msg[1]: id
            //   - msg[2]: method name
            //   - msg[3]: arguments
            this.emit('request', msg[2].toString(), msg[3], this.createResponse(msg[1]));
        }
        else if (msgType === 1) {
            // response to a previous request:
            //   - msg[1]: the id
            //   - msg[2]: error(if any)
            //   - msg[3]: result(if not errored)
            const id = msg[1];
            const handler = this.pending.get(id);
            if (handler) {
                this.pending.delete(id);
                let err = msg[2];
                if (err && err.length != 2) {
                    err = [0, err instanceof Error ? err.message : err];
                }
                handler(err, msg[3]);
            }
        }
        else if (msgType === 2) {
            // notification/event
            //   - msg[1]: event name
            //   - msg[2]: arguments
            this.emit('notification', msg[1].toString(), msg[2]);
        }
        else {
            // tslint:disable-next-line: no-console
            console.error(`Invalid message type ${msgType}`);
        }
    }
    setupCodec() {
        const codec = msgpack.createCodec();
        types_1.Metadata.forEach(({ constructor }, id) => {
            codec.addExtPacker(id, constructor, (obj) => msgpack.encode(obj.data));
            codec.addExtUnpacker(id, data => new constructor({
                transport: this,
                client: this.client,
                data: msgpack.decode(data),
            }));
        });
        this.codec = codec;
        return this.codec;
    }
    attach(writer, reader, client) {
        this.encodeStream = this.encodeStream.pipe(writer);
        const buffered = new buffered_1.default();
        reader.pipe(buffered).pipe(this.decodeStream);
        this.writer = writer;
        this.reader = reader;
        this.client = client;
        this.attached = true;
    }
    detach() {
        if (!this.attached)
            return;
        this.attached = false;
        this.encodeStream.unpipe(this.writer);
        this.reader.unpipe(this.decodeStream);
    }
    request(method, args, cb) {
        if (!this.attached)
            return;
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId + 1;
        let startTs = Date.now();
        this.debug('request to nvim:', id, method, args);
        this.encodeStream.write(msgpack.encode([0, id, method, args], {
            codec: this.codec,
        }));
        let timer = setTimeout(() => {
            this.debug(`request to nvim cost more than 1s`, method, args);
        }, 1000);
        this.pending.set(id, (err, res) => {
            clearTimeout(timer);
            this.debug('response of nvim:', id, `${Date.now() - startTs}ms`, res, err);
            cb(err, res);
        });
    }
    notify(method, args) {
        if (!this.attached)
            return;
        if (this.pauseLevel != 0) {
            let arr = this.paused.get(this.pauseLevel);
            if (arr) {
                arr.push([method, args]);
                return;
            }
        }
        this.debug('nvim notification:', method, args);
        this.encodeStream.write(msgpack.encode([2, method, args], {
            codec: this.codec,
        }));
    }
    send(arr) {
        this.encodeStream.write(msgpack.encode(arr, {
            codec: this.codec,
        }));
    }
    createResponse(requestId) {
        let { encodeStream } = this;
        let startTs = Date.now();
        let called = false;
        let timer = setTimeout(() => {
            this.debug(`request to client cost more than 1s`, requestId);
        }, 1000);
        return {
            send: (resp, isError) => {
                clearTimeout(timer);
                if (called || !this.attached)
                    return;
                this.debug('response of client:', requestId, `${Date.now() - startTs}ms`, resp, isError == true);
                called = true;
                encodeStream.write(msgpack.encode([
                    1,
                    requestId,
                    isError ? resp : null,
                    !isError ? resp : null,
                ]));
            }
        };
    }
}
exports.NvimTransport = NvimTransport;
