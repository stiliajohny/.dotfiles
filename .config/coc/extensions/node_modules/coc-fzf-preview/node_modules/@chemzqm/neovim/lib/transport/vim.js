"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const base_1 = __importDefault(require("./base"));
const connection_1 = __importDefault(require("./connection"));
const request_1 = __importDefault(require("./request"));
class VimTransport extends base_1.default {
    constructor() {
        super();
        this.pending = new Map();
        this.nextRequestId = -1;
        this.attached = false;
        this.notifyMethod = process.env.COC_NVIM == '1' ? 'coc#api#notify' : 'nvim#api#notify';
    }
    attach(writer, reader, client) {
        let connection = this.connection = new connection_1.default(reader, writer);
        this.attached = true;
        this.client = client;
        connection.on('request', (id, obj) => {
            let [method, args] = obj;
            this.emit('request', method, args, this.createResponse(id));
        });
        connection.on('notification', (obj) => {
            let [event, args] = obj;
            this.emit('notification', event.toString(), args);
        });
        connection.on('response', (id, obj) => {
            let req = this.pending.get(id);
            if (req) {
                this.pending.delete(id);
                let err = null;
                let result = null;
                if (!Array.isArray(obj)) {
                    err = obj;
                }
                else {
                    err = obj[0];
                    result = obj[1];
                }
                req.callback(this.client, err, result);
            }
        });
    }
    send(arr) {
        this.connection.send(arr);
    }
    detach() {
        if (!this.attached)
            return;
        this.attached = false;
        this.connection.dispose();
    }
    /**
     * Send request to vim
     */
    request(method, args, cb) {
        if (!this.attached)
            return cb([0, 'transport disconnected']);
        let id = this.nextRequestId;
        this.nextRequestId = this.nextRequestId - 1;
        let startTs = Date.now();
        this.debug('request to vim:', id, method, args);
        let timer = setTimeout(() => {
            this.debug(`request to vim cost more than 1s`, method, args);
        }, 1000);
        let req = new request_1.default(this.connection, (err, res) => {
            clearTimeout(timer);
            this.debug(`response from vim cost:`, id, `${Date.now() - startTs}ms`);
            cb(err, res);
        }, id);
        this.pending.set(id, req);
        req.request(method, args);
    }
    notify(method, args) {
        if (!this.attached)
            return;
        if (this.pauseLevel != 0) {
            let arr = this.paused.get(this.pauseLevel);
            if (arr) {
                arr.push([method, args]);
                return;
            }
        }
        this.connection.call(this.notifyMethod, [method.slice(5), args]);
    }
    createResponse(requestId) {
        let called = false;
        let { connection } = this;
        let startTs = Date.now();
        let timer = setTimeout(() => {
            this.debug(`request to client cost more than 1s`, requestId);
        }, 1000);
        return {
            send: (resp, isError) => {
                clearTimeout(timer);
                if (called || !this.attached)
                    return;
                called = true;
                let err = null;
                if (isError)
                    err = typeof resp === 'string' ? resp : resp.toString();
                this.debug('response of client cost:', requestId, `${Date.now() - startTs}ms`);
                connection.response(requestId, [err, isError ? null : resp]);
            }
        };
    }
}
exports.VimTransport = VimTransport;
